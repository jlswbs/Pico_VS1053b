
/* Code automatically generated by Vult https://github.com/modlfo/vult */
#ifndef ADSR_H
#define ADSR_H
#include <stdint.h>
#include <math.h>
#include "vultin.h"

typedef struct Adsr__ctx_type_0 {
   uint8_t pre;
} Adsr__ctx_type_0;

typedef Adsr__ctx_type_0 Adsr_edge_type;

static_inline void Adsr__ctx_type_0_init(Adsr__ctx_type_0 &_output_){
   Adsr__ctx_type_0 _ctx;
   _ctx.pre = false;
   _output_ = _ctx;
   return ;
}

static_inline void Adsr_edge_init(Adsr__ctx_type_0 &_output_){
   Adsr__ctx_type_0_init(_output_);
   return ;
}

static_inline uint8_t Adsr_edge(Adsr__ctx_type_0 &_ctx, uint8_t x){
   uint8_t ret;
   ret = (x && bool_not(_ctx.pre));
   _ctx.pre = x;
   return ret;
}

typedef struct Adsr__ctx_type_1 {
   fix16_t x;
} Adsr__ctx_type_1;

typedef Adsr__ctx_type_1 Adsr_smooth_type;

static_inline void Adsr__ctx_type_1_init(Adsr__ctx_type_1 &_output_){
   Adsr__ctx_type_1 _ctx;
   _ctx.x = 0x0 /* 0.000000 */;
   _output_ = _ctx;
   return ;
}

static_inline void Adsr_smooth_init(Adsr__ctx_type_1 &_output_){
   Adsr__ctx_type_1_init(_output_);
   return ;
}

static_inline fix16_t Adsr_smooth(Adsr__ctx_type_1 &_ctx, fix16_t input){
   _ctx.x = (_ctx.x + fix_mul(0x147 /* 0.005000 */,(input + (- _ctx.x))));
   return _ctx.x;
}

typedef struct Adsr__ctx_type_2 {
   fix16_t target;
   int state;
   fix16_t scale;
   fix16_t rate;
   fix16_t out;
   Adsr__ctx_type_1 _inst981;
   Adsr__ctx_type_0 _inst2b7;
} Adsr__ctx_type_2;

typedef Adsr__ctx_type_2 Adsr_process_type;

void Adsr__ctx_type_2_init(Adsr__ctx_type_2 &_output_);

static_inline void Adsr_process_init(Adsr__ctx_type_2 &_output_){
   Adsr__ctx_type_2_init(_output_);
   return ;
}

fix16_t Adsr_process(Adsr__ctx_type_2 &_ctx, fix16_t gate, fix16_t a, fix16_t d, fix16_t s, fix16_t r);



#endif // ADSR_H
